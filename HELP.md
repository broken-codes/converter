# Converter

## Introduction

This application provides an implementation for converting CSV file to JSON objects. The application converts each
record of the CSV file into individual JSON object and writes them to their own file.

## Requirements

Any modern system should be good enough to run the application. The application uses following tools installed on the
system it is supposed to be built and run:

1. Java (1.8+)
2. Maven (3.8.3)

The version mentioned after the tools is the one that was used when developing the application.

## Setup Guide

The application needs to be built before it could be run. Application has plugins for `code coverage` and `mutation`
testing. In order to generate coverage report and mutation reports, the application could be built in `coverage-pit`
profile as:

```
    mvn clean package -P coverage-pit
```

The reports generated by these plugins could be found under following directories:

**Coverage Report:** `target/site/jacoco`

**PIT Report:** `target/pit-reports`

If the profile is not specified, the reports will not be generated and would provide better build times. Once the
application is built, the application could be run using following commands:

```
    java -jar target/converter.jar
```

## Application configuration

Application allows room for configuration. In current release, following configurations could be altered:

1. Input CSV file name: Name of the CSV file being processed. This is required configuration.
2. Output directory location: The directory where the final json objects must be written.
3. Output formats: Different formats of output that should be generated. Default selection is JSON

The configuration changes could be made in the `application.yml` file.

## Extending application functionalities to include support for other file formats

The application provides extension functionalities through the APIs listed
in `org.aiolabs.projects.converter.types.contracts`
package. The API supports two types:

1. Reader
2. Writer

### Reader

Represents the type that could be read. All readers implement `ObservableTypeReader`. The interface provides a single
method to read a file.

```java
    void read(String inputFileName);
```

Any new file format implementation that should be read as an input must provide an implementation to this `read(...)`
method. `AbstractObservableTypeReader` is an abstract class that implements `ObservableTypeReader` interface. This class
has built in logic for:

1. Identifying Writers
2. Transferring data to the Writers for the data to be written to a file

When the application is starting, this class lists out all the `Components` that implement `ObservableTypeReader` and
are marked with `@Observer` annotation. It then registers these classes as observers for the data that is produced by
`read(...)`. Whenever a new data is produced (read) by the reader, the data is published to all the `@Observer`s. This
mechanism helps in decoupling readers from writers. Its a good practice to extend this class to create custom
`ObservableTypeReader`. Once this is done, the implementation now just needs to implement the `read(...)` such that it
reads one record at a time and publishes it by calling `publish(...)` of `AbstractObservableReaderType`. Here is a
sample implementation for CSV reader:

```java
    @Override
public void read(String inputFileName){
final Set<Integer> readHashes=new HashSet<>();
        int count=0;

        BufferedReader reader=ioUtils.reader(inputFileName);

        CsvToBean<Profile> converter=beanReader.toReader(reader);

        for(final Profile profile:converter){
        if(readHashes.contains(profile.hashCode())){
        continue;
        }
        readHashes.add(profile.hashCode());
        publish(profile,++count);
        }
        }
```

### Writer

This type represents writers that get notification and write data to the disk. Each writer must
implement `OnservingTypeWriter`. This interface provides only one method that receives data and the position of the data
in the original input file. All this implementation needs to do is to know how to write this data to the file.

```java
    CompletableFuture<Void> write(T type,int dataPositionInFile);
```

The method returns a `CompletableFuture<T>` which is just used for synchronization purposes
by `AbstractObservableTypeReader`. One thing that the implementation must keep in mind is that the writer must always be
marked with `@Observer` so that it could be automatically be picked up and registered.